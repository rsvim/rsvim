use crate::prelude::*;
use compact_str::CompactString;
use compact_str::ToCompactString;
use crossterm::style::Attribute;
use crossterm::style::Attributes;
use crossterm::style::Color;
use std::fmt;

// "ui."
pub const FOREGROUND: &str = "foreground";
pub const BACKGROUND: &str = "background";
pub const UI_FOREGROUND: &str = "ui.foreground";
pub const UI_BACKGROUND: &str = "ui.background";

// "scope.{lang}."
pub const ATTRIBUTE: &str = "attribute";
pub const BOOLEAN: &str = "boolean";
pub const CARRIAGE_RETURN: &str = "carriage-return";
pub const COMMENT: &str = "comment";
pub const COMMENT_DOCUMENTATION: &str = "comment.documentation";
pub const CONSTANT: &str = "constant";
pub const CONSTANT_BUILTIN: &str = "constant.builtin";
pub const CONSTRUCTOR: &str = "constructor";
pub const CONSTRUCTOR_BUILTIN: &str = "constructor.builtin";
pub const EMBEDDED: &str = "embedded";
pub const ERROR: &str = "error";
pub const ESCAPE: &str = "escape";
pub const FUNCTION: &str = "function";
pub const FUNCTION_BUILTIN: &str = "function.builtin";
pub const KEYWORD: &str = "keyword";
pub const MARKUP: &str = "markup";
pub const MARKUP_BOLD: &str = "markup.bold";
pub const MARKUP_HEADING: &str = "markup.heading";
pub const MARKUP_ITALIC: &str = "markup.italic";
pub const MARKUP_LINK: &str = "markup.link";
pub const MARKUP_LINK_URL: &str = "markup.link.url";
pub const MARKUP_LIST: &str = "markup.list";
pub const MARKUP_LIST_CHECKED: &str = "markup.list.checked";
pub const MARKUP_LIST_NUMBERED: &str = "markup.list.numbered";
pub const MARKUP_LIST_UNCHECKED: &str = "markup.list.unchecked";
pub const MARKUP_LIST_UNNUMBERED: &str = "markup.list.unnumbered";
pub const MARKUP_QUOTE: &str = "markup.quote";
pub const MARKUP_RAW: &str = "markup.raw";
pub const MARKUP_RAW_BLOCK: &str = "markup.raw.block";
pub const MARKUP_RAW_INLINE: &str = "markup.raw.inline";
pub const MARKUP_STRIKETHROUGH: &str = "markup.strikethrough";
pub const MODULE: &str = "module";
pub const NUMBER: &str = "number";
pub const OPERATOR: &str = "operator";
pub const PROPERTY: &str = "property";
pub const PROPERTY_BUILTIN: &str = "property.builtin";
pub const PUNCTUATION: &str = "punctuation";
pub const PUNCTUATION_BRACKET: &str = "punctuation.bracket";
pub const PUNCTUATION_DELIMITER: &str = "punctuation.delimiter";
pub const PUNCTUATION_SPECIAL: &str = "punctuation.special";
pub const STRING: &str = "string";
pub const STRING_ESCAPE: &str = "string.escape";
pub const STRING_REGEXP: &str = "string.regexp";
pub const STRING_SPECIAL: &str = "string.special";
pub const STRING_SPECIAL_SYMBOL: &str = "string.special.symbol";
pub const TAG: &str = "tag";
pub const TYPE: &str = "type";
pub const TYPE_BUILTIN: &str = "type.builtin";
pub const VARIABLE: &str = "variable";
pub const VARIABLE_BUILTIN: &str = "variable.builtin";
pub const VARIABLE_MEMBER: &str = "variable.member";
pub const VARIABLE_PARAMETER: &str = "variable.parameter";

fn deserialize_color<E>(s: &str) -> Result<Color, E>
where
  E: serde::de::Error,
{
  let parse_hex = |x| {
    u8::from_str_radix(x, 16)
      .map_err(|e| serde::de::Error::custom(format!("{}: {:?}", s, e)))
  };

  if s.starts_with("#") && s.len() == 7 {
    // Parse hex 6 digits, for example: #ffffff
    let s = &s[1..];
    let r = parse_hex(&s[0..2])?;
    let g = parse_hex(&s[2..4])?;
    let b = parse_hex(&s[4..6])?;
    Ok(Color::Rgb { r, g, b })
  } else if s.starts_with("#") && s.len() == 4 {
    // Parse hex 3 digits, for example: #fff
    let s = &s[1..];
    let r = parse_hex(&s[0..1])?;
    let r = r | (r << 4);
    let g = parse_hex(&s[1..2])?;
    let g = g | (g << 4);
    let b = parse_hex(&s[2..3])?;
    let b = b | (b << 4);
    Ok(Color::Rgb { r, g, b })
  } else {
    Color::try_from(s).map_err(|e| {
      serde::de::Error::custom(format!(
        "Failed to parse color `{}`: {:?}",
        s, e
      ))
    })
  }
}

#[derive(Debug, Clone, PartialEq, Eq)]
/// Highlight style, including colors and attributes.
pub struct Highlight {
  pub fg: Option<Color>,
  pub bg: Option<Color>,
  pub attr: Attributes,
}

struct HighlightVisitor;

impl<'de> serde::de::Visitor<'de> for HighlightVisitor {
  type Value = Highlight;

  fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
    formatter.write_str("highlight attributes table or color string")
  }

  fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
  where
    A: serde::de::MapAccess<'de>,
  {
    let mut fg: Option<Color> = None;
    let mut bg: Option<Color> = None;
    let mut bold = false;
    let mut italic = false;
    let mut underlined = false;

    while let Some(key) = map.next_key::<String>()? {
      match key.as_str() {
        "fg" => {
          let s: String = map.next_value()?;
          fg = Some(deserialize_color(&s)?);
        }
        "bg" => {
          let s: String = map.next_value()?;
          bg = Some(deserialize_color(&s)?);
        }
        "bold" => bold = map.next_value()?,
        "italic" => italic = map.next_value()?,
        "underlined" => underlined = map.next_value()?,
        _ => {
          let _: serde::de::IgnoredAny = map.next_value()?;
        }
      }
    }

    let mut attr = Attributes::none();
    if bold {
      attr.set(Attribute::Bold);
    }
    if italic {
      attr.set(Attribute::Italic);
    }
    if underlined {
      attr.set(Attribute::Underlined);
    }

    Ok(Highlight { fg, bg, attr })
  }

  fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
  where
    E: serde::de::Error,
  {
    let fg = Some(deserialize_color(v)?);
    let bg = None;
    let attr = Attributes::none();
    Ok(Highlight { fg, bg, attr })
  }
}

impl<'de> serde::Deserialize<'de> for Highlight {
  fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  where
    D: serde::Deserializer<'de>,
  {
    deserializer.deserialize_any(HighlightVisitor)
  }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Data {
  pub scope: FoldMap<CompactString, Highlight>,
  pub ui: FoldMap<CompactString, Color>,
}

struct PaletteData {
  pub palette: FoldMap<CompactString, Color>,
}

struct PaletteMapVisitor;

impl<'de> serde::de::Visitor<'de> for PaletteMapVisitor {
  type Value = FoldMap<CompactString, Color>;

  fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
    formatter.write_str("palette table")
  }

  fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
  where
    A: serde::de::MapAccess<'de>,
  {
    let mut palette: FoldMap<CompactString, Color> = FoldMap::new();

    while let Some(key) = map.next_key::<String>()? {
      let value = map.next_value::<String>()?;
      let value = deserialize_color(&value)?;
      palette.insert(key.to_compact_string(), value);
    }

    Ok(palette)
  }
}

struct PaletteDataVisitor;

impl<'de> serde::de::Visitor<'de> for PaletteDataVisitor {
  type Value = FoldMap<CompactString, Color>;

  fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
    formatter.write_str("palette table")
  }

  fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
  where
    A: serde::de::MapAccess<'de>,
  {
    while let Some(key) = map.next_key::<String>()? {
      match key.as_str() {
        "palette" => {
          let palette_map = map.next_value::<>
        }
        _ => {
          let _: serde::de::IgnoredAny = map.next_value()?;
        }
      }
      let value = map.next_value::<String>()?;
      let value = deserialize_color(&value)?;
      palette.insert(key.to_compact_string(), value);
    }

    Ok(palette)
  }
}

impl<'de> serde::Deserialize<'de> for PaletteData {
  fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  where
    D: serde::Deserializer<'de>,
  {
  }
}
